Diagram Explanation
1.Ingestion and Trigger:

Incoming EOD File: The process starts when a new file is uploaded, typically at the end of day.

Azure Blob Storage (Icon: Blob): The file is stored in Blob Storage, which provides scalable, durable storage. This same Blob Storage later holds the final aggregated output file.

Azure Function with Blob Trigger (Icon: Function): As soon as the file is uploaded, an Azure Function is triggered by a Blob event. This function is responsible for reading the file, splitting it into manageable chunks based on record thresholds, and initiating the next step.

2.Messaging and Processing:

Azure Service Bus (Icon: Service Bus): Each chunk generated by the file splitter is represented as a message and placed onto the Service Bus queue. This decouples the splitting step from processing and provides reliable messaging capabilities.

Java Spring Boot Microservice on AKS (Icon: Kubernetes): Containerized microservices (running Java Spring Boot) deployed on Azure Kubernetes Service (AKS) pull messages from the Service Bus. They process each chunk in parallel (applying enrichment logic and handling errors) and send the processed data for aggregation.

3.Aggregation:

Aggregation Microservice on AKS (Icon: Kubernetes/Data Factory): Once all the chunks have been processed, an aggregation microservice collects the enriched chunks and merges them into a single, consolidated output file. This file is then stored back in Azure Blob Storage for consumption by downstream systems or for further processing.